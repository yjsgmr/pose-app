<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>Pose Tracking Debug</title>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose@0.5/pose.js"></script>

  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #111827;
      color: #e5e7eb;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 16px;
      gap: 12px;
    }
    h1 { font-size: 1.2rem; margin-bottom: 4px; }
    .app-container {
      width: 100%;
      max-width: 480px;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    .controls {
      display: flex;
      gap: 8px;
      align-items: center;
      justify-content: space-between;
    }
    label { font-size: 0.85rem; }
    select {
      flex: 1;
      padding: 6px 8px;
      border-radius: 999px;
      border: 1px solid #374151;
      background: #020617;
      color: #e5e7eb;
      font-size: 0.9rem;
    }
    button {
      padding: 6px 10px;
      border-radius: 999px;
      border: none;
      font-size: 0.85rem;
      cursor: pointer;
      background: #f97316;
      color: white;
      font-weight: 600;
    }
    button:disabled { opacity: 0.4; cursor: not-allowed; }

    .video-wrapper {
      position: relative;
      width: 100%;
      border-radius: 24px;
      overflow: hidden;
      box-shadow: 0 18px 45px rgba(0, 0, 0, 0.6);
      background: black;
      aspect-ratio: 3 / 4;
    }
    video {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
      transform: scaleX(-1);
      display: block; /* カメラ映像も見えるように */
    }
    canvas {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      transform: scaleX(-1);
      pointer-events: none;
    }
    .hint {
      font-size: 0.75rem;
      color: #9ca3af;
      margin-top: 4px;
      line-height: 1.4;
    }
    .status {
      font-size: 0.75rem;
      color: #22c55e;
      margin-top: 4px;
      word-break: break-all;
    }
  </style>
</head>
<body>
  <div class="app-container">
    <h1>骨格検出 &amp; 軌跡表示デモ（デバッグ版）</h1>

    <div class="controls">
      <label for="target">追跡パーツ：</label>
      <select id="target">
        <option value="center">体の中心</option>
        <option value="nose">頭（鼻）</option>
        <option value="left_wrist">左手首</option>
        <option value="right_wrist">右手首</option>
        <option value="left_ankle">左足首</option>
        <option value="right_ankle">右足首</option>
      </select>
      <button id="clear">軌跡クリア</button>
    </div>

    <div class="video-wrapper">
      <video id="video" playsinline autoplay muted></video>
      <canvas id="output"></canvas>
    </div>

    <p class="hint">
      ・明るい場所で、体全体が映るように少し離れて立ってください。<br />
      ・インカメラ（自撮り）の映像に水色の骨格が重なれば成功です。
    </p>
    <p class="status" id="status">初期化中...</p>
  </div>

  <script>
    const videoElement = document.getElementById("video");
    const canvasElement = document.getElementById("output");
    const canvasCtx = canvasElement.getContext("2d");
    const statusEl = document.getElementById("status");

    const targetSelect = document.getElementById("target");
    const clearButton = document.getElementById("clear");
    let trailPoints = [];

    const LANDMARK_INDEX = {
      nose: 0,
      left_shoulder: 11,
      right_shoulder: 12,
      left_elbow: 13,
      right_elbow: 14,
      left_wrist: 15,
      right_wrist: 16,
      left_hip: 23,
      right_hip: 24,
      left_knee: 25,
      right_knee: 26,
      left_ankle: 27,
      right_ankle: 28,
    };

    const SKELETON_CONNECTIONS = [
      ["left_shoulder", "right_shoulder"],
      ["left_shoulder", "left_hip"],
      ["right_shoulder", "right_hip"],
      ["left_hip", "right_hip"],
      ["left_shoulder", "left_elbow"],
      ["left_elbow", "left_wrist"],
      ["right_shoulder", "right_elbow"],
      ["right_elbow", "right_wrist"],
      ["left_hip", "left_knee"],
      ["left_knee", "left_ankle"],
      ["right_hip", "right_knee"],
      ["right_knee", "right_ankle"],
      ["nose", "left_shoulder"],
      ["nose", "right_shoulder"],
    ];

    clearButton.addEventListener("click", () => {
      trailPoints = [];
    });

    function setStatus(msg) {
      statusEl.textContent = msg;
    }

    function resizeCanvas() {
      const rect = canvasElement.getBoundingClientRect();
      canvasElement.width = rect.width;
      canvasElement.height = rect.height;
    }

    window.addEventListener("resize", resizeCanvas);

    // Pose 初期化
    let pose;
    try {
      pose = new Pose.Pose({
        locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/pose@0.5/${file}`,
      });
      pose.setOptions({
        modelComplexity: 1,
        smoothLandmarks: true,
        enableSegmentation: false,
        selfieMode: true,                 // ← インカメラ想定
        minDetectionConfidence: 0.3,      // ← 少しゆるく
        minTrackingConfidence: 0.3,
      });
      pose.onResults(onResults);
      setStatus("Pose 初期化完了。カメラ起動中...");
    } catch (e) {
      console.error(e);
      setStatus("Pose の初期化でエラーが発生しました: " + e.message);
    }

    async function startCamera() {
      try {
        setStatus("カメラアクセス要求中...");
        const stream = await navigator.mediaDevices.getUserMedia({
          video: { facingMode: "user" },
          audio: false,
        });
        videoElement.srcObject = stream;
        await videoElement.play();
        setStatus("カメラ起動成功。Pose 処理中...");
        requestAnimationFrame(processFrame);
      } catch (err) {
        console.error(err);
        setStatus("カメラ取得に失敗しました。権限やHTTPSを確認してください: " + err.message);
      }
    }

    async function processFrame() {
      if (pose && videoElement.readyState >= 2) {
        try {
          await pose.send({ image: videoElement });
        } catch (e) {
          console.error(e);
          setStatus("Pose 処理中にエラー: " + e.message);
        }
      }
      requestAnimationFrame(processFrame);
    }

    function onResults(results) {
      resizeCanvas();
      canvasCtx.save();
      canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);

      // カメラ映像
      if (results.image) {
        canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);
      }

      const landmarks = results.poseLandmarks;
      if (!landmarks) {
        setStatus("Pose: ランドマーク未検出（体全体が映るように少し下がってみてください）");
        canvasCtx.restore();
        return;
      } else {
        setStatus("Pose: ランドマーク検出中！");
      }

      drawSkeleton(landmarks);

      const targetKey = targetSelect.value;
      const targetPoint = getTargetPoint(targetKey, landmarks);
      if (targetPoint) {
        const px = targetPoint.x * canvasElement.width;
        const py = targetPoint.y * canvasElement.height;
        trailPoints.push({ x: px, y: py });

        const MAX_POINTS = 200;
        if (trailPoints.length > MAX_POINTS) {
          trailPoints.splice(0, trailPoints.length - MAX_POINTS);
        }
      }

      drawTrail();
      canvasCtx.restore();
    }

    function drawSkeleton(landmarks) {
      canvasCtx.lineWidth = 3;
      canvasCtx.strokeStyle = "#00e5ff";
      SKELETON_CONNECTIONS.forEach(([aKey, bKey]) => {
        const a = landmarks[LANDMARK_INDEX[aKey]];
        const b = landmarks[LANDMARK_INDEX[bKey]];
        if (!a || !b) return;
        const ax = a.x * canvasElement.width;
        const ay = a.y * canvasElement.height;
        const bx = b.x * canvasElement.width;
        const by = b.y * canvasElement.height;
        canvasCtx.beginPath();
        canvasCtx.moveTo(ax, ay);
        canvasCtx.lineTo(bx, by);
        canvasCtx.stroke();
      });

      canvasCtx.fillStyle = "#00e5ff";
      landmarks.forEach((lm) => {
        const x = lm.x * canvasElement.width;
        const y = lm.y * canvasElement.height;
        canvasCtx.beginPath();
        canvasCtx.arc(x, y, 3, 0, Math.PI * 2);
        canvasCtx.fill();
      });
    }

    function drawTrail() {
      if (trailPoints.length < 2) return;
      canvasCtx.lineWidth = 4;
      canvasCtx.strokeStyle = "#ff9800";
      canvasCtx.beginPath();
      for (let i = 0; i < trailPoints.length; i++) {
        const p = trailPoints[i];
        if (i === 0) canvasCtx.moveTo(p.x, p.y);
        else canvasCtx.lineTo(p.x, p.y);
      }
      canvasCtx.stroke();
    }

    function getTargetPoint(key, landmarks) {
      if (key === "center") {
        const ls = landmarks[LANDMARK_INDEX.left_shoulder];
        const rs = landmarks[LANDMARK_INDEX.right_shoulder];
        const lh = landmarks[LANDMARK_INDEX.left_hip];
        const rh = landmarks[LANDMARK_INDEX.right_hip];
        if (!ls || !rs || !lh || !rh) return null;
        const cx = (ls.x + rs.x + lh.x + rh.x) / 4;
        const cy = (ls.y + rs.y + lh.y + rh.y) / 4;
        return { x: cx, y: cy };
      }
      const index = LANDMARK_INDEX[key];
      return landmarks[index] || null;
    }

    // 起動
    setStatus("初期化完了。カメラ起動を開始します。");
    startCamera();
  </script>
</body>
</html>
