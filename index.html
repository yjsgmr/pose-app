<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>Pose Tracking – 軌跡ON/OFF・録画・カメラ全切替付き</title>
  <!-- MediaPipe Pose 本体 -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose@0.5/pose.js"></script>

  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #111827;
      color: #e5e7eb;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 16px;
      gap: 12px;
    }
    h1 { font-size: 1.2rem; margin-bottom: 4px; text-align: center; }
    .app-container {
      width: 100%;
      max-width: 520px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      align-items: stretch;
    }
    .row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
      justify-content: space-between;
    }
    label { font-size: 0.9rem; }
    select {
      flex: 1;
      min-width: 140px;
      padding: 8px 12px;
      border-radius: 999px;
      border: 1px solid #374151;
      background: #020617;
      color: #e5e7eb;
      font-size: 0.95rem;
    }
    button {
      padding: 12px 18px;         /* ← 以前の約2倍 */
      border-radius: 999px;
      border: none;
      font-size: 1rem;            /* ← 大きめの文字 */
      cursor: pointer;
      background: #f97316;
      color: white;
      font-weight: 600;
      white-space: nowrap;
      flex-shrink: 0;
    }
    button:disabled {
      opacity: 0.4;
      cursor: not-allowed;
    }
    .checkbox-label {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      font-size: 0.9rem;
    }
    input[type="checkbox"] {
      width: 16px;
      height: 16px;
    }

    .video-wrapper {
      position: relative;
      width: 100%;
      border-radius: 24px;
      overflow: hidden;
      box-shadow: 0 18px 45px rgba(0, 0, 0, 0.6);
      background: black;
      aspect-ratio: 3 / 4;
    }
    video {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
      transform: scaleX(-1);
      display: block;
    }
    canvas {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      transform: scaleX(-1);
      pointer-events: none;
    }
    .hint {
      font-size: 0.8rem;
      color: #9ca3af;
      margin-top: 4px;
      line-height: 1.4;
      text-align: center;
    }
    .status {
      font-size: 0.8rem;
      color: #22c55e;
      margin-top: 4px;
      word-break: break-all;
      text-align: center;
    }
  </style>
</head>
<body>
  <div class="app-container">
    <h1>骨格検出 &amp; 軌跡表示<br>（軌跡ON/OFF・録画・カメラ全切替付き）</h1>

    <!-- 上段：追跡パーツ・軌跡 ON/OFF -->
    <div class="row">
      <label for="target">追跡パーツ：</label>
      <select id="target">
        <option value="center">体の中心</option>
        <option value="nose">頭（鼻）</option>
        <option value="left_wrist">左手首</option>
        <option value="right_wrist">右手首</option>
        <option value="left_ankle">左足首</option>
        <option value="right_ankle">右足首</option>
      </select>

      <label class="checkbox-label">
        <input type="checkbox" id="trailToggle" checked />
        軌跡表示
      </label>

      <button id="clearTrail">軌跡クリア</button>
    </div>

    <!-- 中段：録画・再生・カメラ切替 -->
    <div class="row">
      <button id="startRecord">記録開始</button>
      <button id="stopRecord" disabled>記録停止</button>
      <button id="playRecord" disabled>リプレイ再生</button>
      <button id="clearRecord" disabled>記録データ削除</button>
    </div>
    <div class="row">
      <button id="switchCamera">カメラ切替（1/1）</button>
    </div>

    <!-- カメラ＆描画 -->
    <div class="video-wrapper">
      <video id="video" playsinline autoplay muted></video>
      <canvas id="output"></canvas>
    </div>

    <p class="hint">
      ・「カメラ切替」で利用可能なすべてのカメラ（前面＋背面複数）を順番に切り替えます。<br>
      ・「記録開始 → 記録停止 → リプレイ再生」で骨格の動きを再生できます（リプレイ時はカメラ映像は非表示）。
    </p>
    <p class="status" id="status">カメラ開始ボタンを押してください。</p>
    <div class="row" style="justify-content:center;">
      <button id="start">カメラ開始</button>
    </div>
  </div>

  <script>
    const videoElement = document.getElementById("video");
    const canvasElement = document.getElementById("output");
    const canvasCtx = canvasElement.getContext("2d");

    const statusEl      = document.getElementById("status");
    const targetSelect  = document.getElementById("target");
    const trailToggle   = document.getElementById("trailToggle");
    const clearTrailBtn = document.getElementById("clearTrail");
    const startButton   = document.getElementById("start");

    const startRecordBtn = document.getElementById("startRecord");
    const stopRecordBtn  = document.getElementById("stopRecord");
    const playRecordBtn  = document.getElementById("playRecord");
    const clearRecordBtn = document.getElementById("clearRecord");
    const switchCameraBtn = document.getElementById("switchCamera");

    // 状態
    let trailPoints = [];
    let isTrailEnabled = true;

    let pose = null;
    let poseReady = false;

    let videoStream = null;
    let loopStarted = false;
    let mode = "live";                // "live" or "replay"

    let isRecording = false;
    let recordedFrames = [];          // 各要素は landmarks 配列
    let replayIndex = 0;

    // カメラデバイス情報
    let videoDevices = [];
    let currentDeviceIndex = 0;
    let devicesInitialized = false;

    function setStatus(msg) {
      statusEl.textContent = msg;
    }

    function resizeCanvas() {
      const rect = canvasElement.getBoundingClientRect();
      canvasElement.width = rect.width;
      canvasElement.height = rect.height;
    }
    window.addEventListener("resize", resizeCanvas);

    // 軌跡 ON/OFF
    trailToggle.addEventListener("change", () => {
      isTrailEnabled = trailToggle.checked;
      if (!isTrailEnabled) {
        trailPoints = [];
      }
    });

    clearTrailBtn.addEventListener("click", () => {
      trailPoints = [];
    });

    // ランドマーク index（顔・膝・足まで拡張）
    const LANDMARK_INDEX = {
      nose: 0,
      left_eye_inner: 1,
      left_eye: 2,
      left_eye_outer: 3,
      right_eye_inner: 4,
      right_eye: 5,
      right_eye_outer: 6,
      left_ear: 7,
      right_ear: 8,
      mouth_left: 9,
      mouth_right: 10,
      left_shoulder: 11,
      right_shoulder: 12,
      left_elbow: 13,
      right_elbow: 14,
      left_wrist: 15,
      right_wrist: 16,
      left_hip: 23,
      right_hip: 24,
      left_knee: 25,
      right_knee: 26,
      left_ankle: 27,
      right_ankle: 28,
      left_heel: 29,
      right_heel: 30,
      left_foot_index: 31,
      right_foot_index: 32,
    };

    // 骨格接続（顔・足も線でつなぐ）
    const SKELETON_CONNECTIONS = [
      // 顔 - 左側
      ["nose", "left_eye_inner"],
      ["left_eye_inner", "left_eye"],
      ["left_eye", "left_eye_outer"],
      ["left_eye_outer", "left_ear"],
      // 顔 - 右側
      ["nose", "right_eye_inner"],
      ["right_eye_inner", "right_eye"],
      ["right_eye", "right_eye_outer"],
      ["right_eye_outer", "right_ear"],
      // 口
      ["mouth_left", "mouth_right"],
      ["nose", "mouth_left"],
      ["nose", "mouth_right"],

      // 胴体
      ["left_shoulder", "right_shoulder"],
      ["left_shoulder", "left_hip"],
      ["right_shoulder", "right_hip"],
      ["left_hip", "right_hip"],

      // 左腕
      ["left_shoulder", "left_elbow"],
      ["left_elbow", "left_wrist"],

      // 右腕
      ["right_shoulder", "right_elbow"],
      ["right_elbow", "right_wrist"],

      // 左脚
      ["left_hip", "left_knee"],
      ["left_knee", "left_ankle"],
      ["left_ankle", "left_heel"],
      ["left_heel", "left_foot_index"],

      // 右脚
      ["right_hip", "right_knee"],
      ["right_knee", "right_ankle"],
      ["right_ankle", "right_heel"],
      ["right_heel", "right_foot_index"],

      // 首〜頭（補助的）
      ["nose", "left_shoulder"],
      ["nose", "right_shoulder"],
    ];

    function getTargetPoint(key, landmarks) {
      if (!landmarks) return null;

      if (key === "center") {
        const ls = landmarks[LANDMARK_INDEX.left_shoulder];
        const rs = landmarks[LANDMARK_INDEX.right_shoulder];
        const lh = landmarks[LANDMARK_INDEX.left_hip];
        const rh = landmarks[LANDMARK_INDEX.right_hip];
        if (!ls || !rs || !lh || !rh) return null;
        const cx = (ls.x + rs.x + lh.x + rh.x) / 4;
        const cy = (ls.y + rs.y + lh.y + rh.y) / 4;
        return { x: cx, y: cy };
      }

      const idx = LANDMARK_INDEX[key];
      return landmarks[idx] || null;
    }

    function drawTrail() {
      if (!isTrailEnabled) return;
      if (trailPoints.length < 2) return;
      canvasCtx.lineWidth = 4;
      canvasCtx.strokeStyle = "#ff9800"; // オレンジ
      canvasCtx.beginPath();
      for (let i = 0; i < trailPoints.length; i++) {
        const p = trailPoints[i];
        if (i === 0) canvasCtx.moveTo(p.x, p.y);
        else canvasCtx.lineTo(p.x, p.y);
      }
      canvasCtx.stroke();
    }

    function drawSkeleton(landmarks) {
      canvasCtx.lineWidth = 3;
      canvasCtx.strokeStyle = "#00e5ff";

      SKELETON_CONNECTIONS.forEach(([aKey, bKey]) => {
        const a = landmarks[LANDMARK_INDEX[aKey]];
        const b = landmarks[LANDMARK_INDEX[bKey]];
        if (!a || !b) return;
        const ax = a.x * canvasElement.width;
        const ay = a.y * canvasElement.height;
        const bx = b.x * canvasElement.width;
        const by = b.y * canvasElement.height;
        canvasCtx.beginPath();
        canvasCtx.moveTo(ax, ay);
        canvasCtx.lineTo(bx, by);
        canvasCtx.stroke();
      });

      canvasCtx.fillStyle = "#00e5ff";
      landmarks.forEach((lm) => {
        const x = lm.x * canvasElement.width;
        const y = lm.y * canvasElement.height;
        canvasCtx.beginPath();
        canvasCtx.arc(x, y, 3, 0, Math.PI * 2);
        canvasCtx.fill();
      });
    }

    // ==== Pose ライブ結果処理 ====
    function onResults(results) {
      if (mode !== "live") {
        // リプレイ中はライブ結果を無視
        return;
      }

      resizeCanvas();
      canvasCtx.save();
      canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);

      if (results.image) {
        canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);
      }

      const landmarks = results.poseLandmarks;
      if (!landmarks) {
        setStatus("Pose: ランドマーク未検出（体全体が映るように少し下がってください）");
        canvasCtx.restore();
        return;
      }

      setStatus("Pose: ランドマーク検出中！");

      drawSkeleton(landmarks);

      // 記録中ならこのフレームを保存（深いコピー）
      if (isRecording) {
        const copy = landmarks.map(lm => ({ ...lm }));
        recordedFrames.push(copy);
        if (recordedFrames.length === 1) {
          playRecordBtn.disabled = false;
          clearRecordBtn.disabled = false;
        }
      }

      // 軌跡更新
      if (isTrailEnabled) {
        const targetKey = targetSelect.value;
        const targetPoint = getTargetPoint(targetKey, landmarks);
        if (targetPoint) {
          const px = targetPoint.x * canvasElement.width;
          const py = targetPoint.y * canvasElement.height;
          trailPoints.push({ x: px, y: py });

          const MAX_POINTS = 200;
          if (trailPoints.length > MAX_POINTS) {
            trailPoints.splice(0, trailPoints.length - MAX_POINTS);
          }
        }
      }

      drawTrail();
      canvasCtx.restore();
    }

    // ==== Pose 初期化（Pose / Pose.Pose 両対応）====
    function initPose() {
      try {
        let PoseClass = null;

        if (typeof Pose === "undefined") {
          setStatus("カメラのみ動作中（Pose グローバルが存在しません）");
          return;
        }

        if (typeof Pose === "function") {
          PoseClass = Pose;
        } else if (typeof Pose === "object" && typeof Pose.Pose === "function") {
          PoseClass = Pose.Pose;
        } else {
          setStatus("カメラのみ動作中（Pose のクラス形状が想定と異なります）");
          return;
        }

        pose = new PoseClass({
          locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/pose@0.5/${file}`,
        });
        pose.setOptions({
          modelComplexity: 1,
          smoothLandmarks: true,
          enableSegmentation: false,
          selfieMode: true,
          minDetectionConfidence: 0.3,
          minTrackingConfidence: 0.3,
        });
        pose.onResults(onResults);
        poseReady = true;
        setStatus("カメラ起動成功。Pose 初期化完了。検出中...");
      } catch (e) {
        console.error(e);
        setStatus("Pose 初期化エラー: " + e.message);
      }
    }

    // ==== カメラデバイス管理 ====
    async function updateDeviceList() {
      try {
        const devices = await navigator.mediaDevices.enumerateDevices();
        videoDevices = devices.filter(d => d.kind === "videoinput");
        if (videoDevices.length === 0) {
          videoDevices = [];
          currentDeviceIndex = 0;
        } else if (!videoDevices[currentDeviceIndex]) {
          currentDeviceIndex = 0;
        }
        updateSwitchLabel();
      } catch (e) {
        console.error(e);
      }
    }

    function updateSwitchLabel() {
      if (videoDevices.length <= 1) {
        switchCameraBtn.textContent = "カメラ切替（1/1）";
      } else {
        switchCameraBtn.textContent =
          `カメラ切替（${currentDeviceIndex + 1}/${videoDevices.length})`;
      }
    }

    async function stopCamera() {
      if (videoStream) {
        videoStream.getTracks().forEach(t => t.stop());
        videoStream = null;
      }
    }

    async function startCameraStream() {
      if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
        setStatus("エラー: このブラウザは getUserMedia に対応していません。Chrome の最新版を使ってください。");
        return;
      }

      try {
        setStatus("カメラアクセス要求中...");

        let constraints;
        if (videoDevices.length > 0 && videoDevices[currentDeviceIndex]) {
          const devId = videoDevices[currentDeviceIndex].deviceId;
          constraints = {
            video: { deviceId: { exact: devId } },
            audio: false,
          };
        } else {
          constraints = {
            video: { facingMode: "user" },
            audio: false,
          };
        }

        const stream = await navigator.mediaDevices.getUserMedia(constraints);
        videoStream = stream;
        videoElement.srcObject = stream;
        await videoElement.play();
        setStatus("カメラ起動成功（Pose 初期化中...）");

        if (!devicesInitialized) {
          devicesInitialized = true;
          await updateDeviceList();
        }

        if (!poseReady) {
          initPose();
        }
      } catch (e) {
        console.error(e);
        setStatus("カメラ取得に失敗しました: " + e.name + " / " + e.message);
      }
    }

    // メインループ（1回だけ開始）
    async function frameLoop() {
      if (poseReady && pose && mode === "live" && videoElement.readyState >= 2) {
        try {
          await pose.send({ image: videoElement });
        } catch (e) {
          console.error(e);
          setStatus("Pose 処理中にエラー: " + e.message);
        }
      }
      if (loopStarted) {
        requestAnimationFrame(frameLoop);
      }
    }

    // ==== 録画・リプレイ ====
    startRecordBtn.addEventListener("click", () => {
      recordedFrames = [];
      isRecording = true;
      mode = "live";
      replayIndex = 0;
      trailPoints = [];
      startRecordBtn.disabled = true;
      stopRecordBtn.disabled = false;
      playRecordBtn.disabled = true;
      clearRecordBtn.disabled = true;
      setStatus("記録中... 動きを終えたら「記録停止」を押してください。");
    });

    stopRecordBtn.addEventListener("click", () => {
      isRecording = false;
      stopRecordBtn.disabled = true;
      startRecordBtn.disabled = false;
      playRecordBtn.disabled = recordedFrames.length === 0;
      clearRecordBtn.disabled = recordedFrames.length === 0;
      if (recordedFrames.length === 0) {
        setStatus("記録がありません。");
      } else {
        setStatus(`記録完了（フレーム数: ${recordedFrames.length}）。「リプレイ再生」で再生できます。`);
      }
    });

    clearRecordBtn.addEventListener("click", () => {
      recordedFrames = [];
      playRecordBtn.disabled = true;
      clearRecordBtn.disabled = true;
      setStatus("記録データを削除しました。");
    });

    playRecordBtn.addEventListener("click", () => {
      if (recordedFrames.length === 0) {
        setStatus("記録データがありません。");
        return;
      }
      mode = "replay";
      isRecording = false;
      replayIndex = 0;
      trailPoints = [];
      setStatus("リプレイ再生中...");

      // リプレイ中はカメラ映像を非表示
      videoElement.style.visibility = "hidden";

      startRecordBtn.disabled = true;
      stopRecordBtn.disabled = true;
      playRecordBtn.disabled = true;

      replayStep();
    });

    // ★ リプレイ速度を 30fps 相当に調整（setTimeout 33ms）
    function replayStep() {
      if (mode !== "replay") return;
      if (replayIndex >= recordedFrames.length) {
        mode = "live";
        setStatus("リプレイ終了。ライブモードに戻りました。");

        // カメラ映像を再表示
        videoElement.style.visibility = "visible";

        startRecordBtn.disabled = false;
        playRecordBtn.disabled = recordedFrames.length === 0;
        clearRecordBtn.disabled = recordedFrames.length === 0;
        return;
      }

      const landmarks = recordedFrames[replayIndex];
      resizeCanvas();
      canvasCtx.save();
      canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);

      // 背景は黒のまま、骨格だけ描画（カメラ映像は非表示）
      drawSkeleton(landmarks);

      if (isTrailEnabled) {
        const targetKey = targetSelect.value;
        const targetPoint = getTargetPoint(targetKey, landmarks);
        if (targetPoint) {
          const px = targetPoint.x * canvasElement.width;
          const py = targetPoint.y * canvasElement.height;
          trailPoints.push({ x: px, y: py });
          const MAX_POINTS = 200;
          if (trailPoints.length > MAX_POINTS) {
            trailPoints.splice(0, trailPoints.length - MAX_POINTS);
          }
        }
      }

      drawTrail();
      canvasCtx.restore();

      replayIndex++;
      // 約 30fps
      if (mode === "replay") {
        setTimeout(replayStep, 33);
      }
    }

    // ==== カメラ切替 ====
    switchCameraBtn.addEventListener("click", async () => {
      if (videoDevices.length <= 1) {
        setStatus("利用可能なカメラが1つだけのため、切り替えできません。");
        return;
      }
      currentDeviceIndex = (currentDeviceIndex + 1) % videoDevices.length;
      updateSwitchLabel();
      await stopCamera();
      await startCameraStream();
    });

    // ==== カメラ開始ボタン ====
    startButton.addEventListener("click", async () => {
      await startCameraStream();
      if (!loopStarted) {
        loopStarted = true;
        frameLoop();
      }
      setStatus("カメラ起動 & Pose 処理中...");
    });
  </script>
</body>
</html>
