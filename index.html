<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>Pose Tracking – 3ビュー + 軌跡・録画・カメラ切替</title>
  <!-- MediaPipe Pose 本体 -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose@0.5/pose.js"></script>

  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #111827;
      color: #e5e7eb;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 16px;
      gap: 12px;
    }
    h1 { font-size: 1.2rem; margin-bottom: 4px; text-align: center; }
    .app-container {
      width: 100%;
      max-width: 600px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      align-items: stretch;
    }
    .row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
      justify-content: space-between;
    }
    label { font-size: 0.9rem; }
    select {
      flex: 1;
      min-width: 140px;
      padding: 8px 12px;
      border-radius: 999px;
      border: 1px solid #374151;
      background: #020617;
      color: #e5e7eb;
      font-size: 0.95rem;
    }
    button {
      padding: 12px 18px;
      border-radius: 999px;
      border: none;
      font-size: 1rem;
      cursor: pointer;
      background: #f97316;
      color: white;
      font-weight: 600;
      white-space: nowrap;
      flex-shrink: 0;
    }
    button:disabled {
      opacity: 0.4;
      cursor: not-allowed;
    }
    .checkbox-label {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      font-size: 0.9rem;
    }
    input[type="checkbox"] {
      width: 16px;
      height: 16px;
    }

    /* ビュー全体のレイアウト */
    .views {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    .view-row {
      display: flex;
      gap: 8px;
      align-items: stretch;
      justify-content: center;
    }

    .view-box {
      position: relative;
      background: black;
      border-radius: 20px;
      overflow: hidden;
      box-shadow: 0 14px 32px rgba(0, 0, 0, 0.6);
    }

    /* 上ビュー：横長・薄め */
    .view-top {
      width: 100%;
      aspect-ratio: 3 / 1;
    }

    /* 下の行：正面（大）＋横（小） */
    .view-front {
      flex: 2;
      aspect-ratio: 3 / 4;
    }
    .view-side {
      flex: 1.2;
      aspect-ratio: 3 / 4;
    }

    video, canvas {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
    }
    video {
      transform: scaleX(-1);
      display: block;
    }
    canvas {
      transform: scaleX(-1);
      pointer-events: none;
    }

    .hint {
      font-size: 0.8rem;
      color: #9ca3af;
      margin-top: 4px;
      line-height: 1.4;
      text-align: center;
    }
    .status {
      font-size: 0.8rem;
      color: #22c55e;
      margin-top: 4px;
      word-break: break-all;
      text-align: center;
    }
  </style>
</head>
<body>
  <div class="app-container">
    <h1>
      骨格検出 &amp; 軌跡表示<br>
      （正面＋横＋上ビュー / 軌跡ON/OFF / 録画 / カメラ全切替）
    </h1>

    <!-- 上段：追跡パーツ・軌跡 ON/OFF -->
    <div class="row">
      <label for="target">追跡パーツ：</label>
      <select id="target">
        <option value="center">体の中心</option>
        <option value="nose">頭（鼻）</option>
        <option value="left_wrist">左手首</option>
        <option value="right_wrist">右手首</option>
        <option value="left_ankle">左足首</option>
        <option value="right_ankle">右足首</option>
      </select>

      <label class="checkbox-label">
        <input type="checkbox" id="trailToggle" checked />
        軌跡表示
      </label>

      <button id="clearTrail">軌跡クリア</button>
    </div>

    <!-- 中段：録画・再生 -->
    <div class="row">
      <button id="startRecord">記録開始</button>
      <button id="stopRecord" disabled>記録停止</button>
      <button id="playRecord" disabled>リプレイ再生</button>
      <button id="clearRecord" disabled>記録データ削除</button>
    </div>

    <!-- カメラ切替 -->
    <div class="row">
      <button id="switchCamera">カメラ切替（1/1）</button>
    </div>

    <!-- 3ビュー（上 / 正面 / 横） -->
    <div class="views">
      <!-- 上から見たビュー（x-z） -->
      <div class="view-row">
        <div class="view-box view-top">
          <canvas id="topCanvas"></canvas>
        </div>
      </div>

      <!-- 正面 + 横並び -->
      <div class="view-row">
        <!-- 正面ビュー（カメラ映像 + 骨格） -->
        <div class="view-box view-front">
          <video id="video" playsinline autoplay muted></video>
          <canvas id="frontCanvas"></canvas>
        </div>
        <!-- 横から見たビュー（z-y） -->
        <div class="view-box view-side">
          <canvas id="sideCanvas"></canvas>
        </div>
      </div>
    </div>

    <p class="hint">
      ・正面ビュー：カメラ映像＋骨格（2D）<br>
      ・上ビュー：x–z 平面（上から見たイメージ）<br>
      ・横ビュー：z–y 平面（横から見たイメージ）<br>
      ・リプレイ中はカメラ映像は非表示で、骨格＋軌跡のみ再生されます。
    </p>
    <p class="status" id="status">カメラ開始ボタンを押してください。</p>
    <div class="row" style="justify-content:center;">
      <button id="start">カメラ開始</button>
    </div>
  </div>

  <script>
    // ==== DOM 取得 ====
    const videoElement    = document.getElementById("video");
    const frontCanvas     = document.getElementById("frontCanvas");
    const topCanvas       = document.getElementById("topCanvas");
    const sideCanvas      = document.getElementById("sideCanvas");
    const frontCtx        = frontCanvas.getContext("2d");
    const topCtx          = topCanvas.getContext("2d");
    const sideCtx         = sideCanvas.getContext("2d");

    const statusEl        = document.getElementById("status");
    const targetSelect    = document.getElementById("target");
    const trailToggle     = document.getElementById("trailToggle");
    const clearTrailBtn   = document.getElementById("clearTrail");
    const startButton     = document.getElementById("start");

    const startRecordBtn  = document.getElementById("startRecord");
    const stopRecordBtn   = document.getElementById("stopRecord");
    const playRecordBtn   = document.getElementById("playRecord");
    const clearRecordBtn  = document.getElementById("clearRecord");
    const switchCameraBtn = document.getElementById("switchCamera");

    // ==== 状態 ====
    // 3D 軌跡用：世界座標 (x, y, z) の配列
    let trailPoints3D = [];
    let isTrailEnabled = true;

    let pose = null;
    let poseReady = false;

    let videoStream = null;
    let loopStarted = false;
    let mode = "live";      // "live" or "replay"

    let isRecording = false;
    let recordedFrames = []; // 各要素 = landmarks 配列（x,y,z,...）
    let replayIndex = 0;

    // リプレイ速度（ミリ秒）
    // 100ms ≒ 10fps（ゆっくりめ）、66ms ≒ 15fps
    const REPLAY_INTERVAL_MS = 100;

    // カメラデバイス情報
    let videoDevices = [];
    let currentDeviceIndex = 0;
    let devicesInitialized = false;

    function setStatus(msg) {
      statusEl.textContent = msg;
    }

    // ==== サイズ調整 ====
    function resizeAllCanvases() {
      [frontCanvas, topCanvas, sideCanvas].forEach(canvas => {
        const rect = canvas.getBoundingClientRect();
        canvas.width = rect.width;
        canvas.height = rect.height;
      });
    }
    window.addEventListener("resize", resizeAllCanvases);

    // ==== 軌跡 ON/OFF ====
    trailToggle.addEventListener("change", () => {
      isTrailEnabled = trailToggle.checked;
      if (!isTrailEnabled) {
        trailPoints3D = [];
      }
    });

    clearTrailBtn.addEventListener("click", () => {
      trailPoints3D = [];
    });

    // ==== ランドマーク index（顔・膝・足まで）====
    const LANDMARK_INDEX = {
      nose: 0,
      left_eye_inner: 1,
      left_eye: 2,
      left_eye_outer: 3,
      right_eye_inner: 4,
      right_eye: 5,
      right_eye_outer: 6,
      left_ear: 7,
      right_ear: 8,
      mouth_left: 9,
      mouth_right: 10,
      left_shoulder: 11,
      right_shoulder: 12,
      left_elbow: 13,
      right_elbow: 14,
      left_wrist: 15,
      right_wrist: 16,
      left_hip: 23,
      right_hip: 24,
      left_knee: 25,
      right_knee: 26,
      left_ankle: 27,
      right_ankle: 28,
      left_heel: 29,
      right_heel: 30,
      left_foot_index: 31,
      right_foot_index: 32,
    };

    // 骨格接続（顔・足も線でつなぐ）
    const SKELETON_CONNECTIONS = [
      // 顔 - 左側
      ["nose", "left_eye_inner"],
      ["left_eye_inner", "left_eye"],
      ["left_eye", "left_eye_outer"],
      ["left_eye_outer", "left_ear"],
      // 顔 - 右側
      ["nose", "right_eye_inner"],
      ["right_eye_inner", "right_eye"],
      ["right_eye", "right_eye_outer"],
      ["right_eye_outer", "right_ear"],
      // 口
      ["mouth_left", "mouth_right"],
      ["nose", "mouth_left"],
      ["nose", "mouth_right"],

      // 胴体
      ["left_shoulder", "right_shoulder"],
      ["left_shoulder", "left_hip"],
      ["right_shoulder", "right_hip"],
      ["left_hip", "right_hip"],

      // 左腕
      ["left_shoulder", "left_elbow"],
      ["left_elbow", "left_wrist"],

      // 右腕
      ["right_shoulder", "right_elbow"],
      ["right_elbow", "right_wrist"],

      // 左脚
      ["left_hip", "left_knee"],
      ["left_knee", "left_ankle"],
      ["left_ankle", "left_heel"],
      ["left_heel", "left_foot_index"],

      // 右脚
      ["right_hip", "right_knee"],
      ["right_knee", "right_ankle"],
      ["right_ankle", "right_heel"],
      ["right_heel", "right_foot_index"],

      // 首〜頭（補助的）
      ["nose", "left_shoulder"],
      ["nose", "right_shoulder"],
    ];

    // ==== 3D ターゲット点（軌跡用）====
    function getTargetPoint3D(key, landmarks) {
      if (!landmarks) return null;

      if (key === "center") {
        const ls = landmarks[LANDMARK_INDEX.left_shoulder];
        const rs = landmarks[LANDMARK_INDEX.right_shoulder];
        const lh = landmarks[LANDMARK_INDEX.left_hip];
        const rh = landmarks[LANDMARK_INDEX.right_hip];
        if (!ls || !rs || !lh || !rh) return null;
        const cx = (ls.x + rs.x + lh.x + rh.x) / 4;
        const cy = (ls.y + rs.y + lh.y + rh.y) / 4;
        const cz = (ls.z + rs.z + lh.z + rh.z) / 4;
        return { x: cx, y: cy, z: cz };
      }

      const idx = LANDMARK_INDEX[key];
      const lm = landmarks[idx];
      if (!lm) return null;
      return { x: lm.x, y: lm.y, z: lm.z };
    }

    // ==== 汎用：2軸投影用の正規化 ====
    function computeAxisRange(landmarks, axisA, axisB) {
      let minA = Infinity, maxA = -Infinity;
      let minB = Infinity, maxB = -Infinity;
      landmarks.forEach(lm => {
        const a = lm[axisA];
        const b = lm[axisB];
        if (a < minA) minA = a;
        if (a > maxA) maxA = a;
        if (b < minB) minB = b;
        if (b > maxB) maxB = b;
      });
      if (!isFinite(minA) || !isFinite(maxA)) { minA = -0.5; maxA = 0.5; }
      if (!isFinite(minB) || !isFinite(maxB)) { minB = -0.5; maxB = 0.5; }

      // 変化が小さすぎるときは少し余裕を持たせる
      if (maxA - minA < 1e-3) { minA -= 0.5; maxA += 0.5; }
      if (maxB - minB < 1e-3) { minB -= 0.5; maxB += 0.5; }

      return { minA, maxA, minB, maxB };
    }

    function projectValue(v, min, max, size, invert = false) {
      const t = (v - min) / (max - min);
      const u = invert ? (1 - t) : t;
      return u * size;
    }

    // ==== 骨格描画（任意2軸投影）====
    function drawSkeletonProjected(landmarks, ctx, width, height, axisPair) {
      const [axisA, axisB] = axisPair; // e.g. ["x","y"], ["x","z"], ["z","y"]

      const { minA, maxA, minB, maxB } = computeAxisRange(landmarks, axisA, axisB);

      ctx.lineWidth = 3;
      ctx.strokeStyle = "#00e5ff";
      ctx.fillStyle = "#00e5ff";

      // 線
      SKELETON_CONNECTIONS.forEach(([aKey, bKey]) => {
        const a = landmarks[LANDMARK_INDEX[aKey]];
        const b = landmarks[LANDMARK_INDEX[bKey]];
        if (!a || !b) return;
        const ax = projectValue(a[axisA], minA, maxA, width, false);
        const ay = projectValue(a[axisB], minB, maxB, height, true);
        const bx = projectValue(b[axisA], minA, maxA, width, false);
        const by = projectValue(b[axisB], minB, maxB, height, true);

        ctx.beginPath();
        ctx.moveTo(ax, ay);
        ctx.lineTo(bx, by);
        ctx.stroke();
      });

      // 点
      landmarks.forEach(lm => {
        const x = projectValue(lm[axisA], minA, maxA, width, false);
        const y = projectValue(lm[axisB], minB, maxB, height, true);
        ctx.beginPath();
        ctx.arc(x, y, 3, 0, Math.PI * 2);
        ctx.fill();
      });
    }

    // ==== 軌跡描画（任意2軸投影）====
    function drawTrailProjected(trail3D, ctx, width, height, axisPair) {
      if (!isTrailEnabled) return;
      if (trail3D.length < 2) return;
      const [axisA, axisB] = axisPair;

      const { minA, maxA, minB, maxB } = (() => {
        let minA = Infinity, maxA = -Infinity;
        let minB = Infinity, maxB = -Infinity;
        trail3D.forEach(p => {
          const a = p[axisA];
          const b = p[axisB];
          if (a < minA) minA = a;
          if (a > maxA) maxA = a;
          if (b < minB) minB = b;
          if (b > maxB) maxB = b;
        });
        if (!isFinite(minA) || !isFinite(maxA)) { minA = -0.5; maxA = 0.5; }
        if (!isFinite(minB) || !isFinite(maxB)) { minB = -0.5; maxB = 0.5; }
        if (maxA - minA < 1e-3) { minA -= 0.5; maxA += 0.5; }
        if (maxB - minB < 1e-3) { minB -= 0.5; maxB += 0.5; }
        return { minA, maxA, minB, maxB };
      })();

      ctx.lineWidth = 4;
      ctx.strokeStyle = "#ff9800";
      ctx.beginPath();
      for (let i = 0; i < trail3D.length; i++) {
        const p = trail3D[i];
        const x = projectValue(p[axisA], minA, maxA, width, false);
        const y = projectValue(p[axisB], minB, maxB, height, true);
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.stroke();
    }

    // ==== ライブ時結果処理 ====
    function onResults(results) {
      if (mode !== "live") {
        return;
      }

      resizeAllCanvases();

      const landmarks = results.poseLandmarks;
      // 正面ビュー：ビデオ＋骨格＋軌跡（x-y）
      frontCtx.save();
      frontCtx.clearRect(0, 0, frontCanvas.width, frontCanvas.height);
      if (results.image) {
        frontCtx.drawImage(results.image, 0, 0, frontCanvas.width, frontCanvas.height);
      }

      if (!landmarks) {
        setStatus("Pose: ランドマーク未検出（体全体が映るように少し下がってください）");
        frontCtx.restore();

        // 上・横ビューも消去
        topCtx.clearRect(0, 0, topCanvas.width, topCanvas.height);
        sideCtx.clearRect(0, 0, sideCanvas.width, sideCanvas.height);
        return;
      }

      setStatus("Pose: ランドマーク検出中！");

      // ライブ時：正面ビュー（x-y）
      drawSkeletonProjected(landmarks, frontCtx, frontCanvas.width, frontCanvas.height, ["x", "y"]);

      // 軌跡用3Dポイント
      if (isTrailEnabled) {
        const targetKey = targetSelect.value;
        const p3d = getTargetPoint3D(targetKey, landmarks);
        if (p3d) {
          trailPoints3D.push(p3d);
          const MAX_POINTS = 200;
          if (trailPoints3D.length > MAX_POINTS) {
            trailPoints3D.splice(0, trailPoints3D.length - MAX_POINTS);
          }
        }
      }

      // 正面軌跡
      drawTrailProjected(trailPoints3D, frontCtx, frontCanvas.width, frontCanvas.height, ["x", "y"]);
      frontCtx.restore();

      // 上ビュー（x-z）
      topCtx.save();
      topCtx.clearRect(0, 0, topCanvas.width, topCanvas.height);
      drawSkeletonProjected(landmarks, topCtx, topCanvas.width, topCanvas.height, ["x", "z"]);
      drawTrailProjected(trailPoints3D, topCtx, topCanvas.width, topCanvas.height, ["x", "z"]);
      topCtx.restore();

      // 横ビュー（z-y）
      sideCtx.save();
      sideCtx.clearRect(0, 0, sideCanvas.width, sideCanvas.height);
      drawSkeletonProjected(landmarks, sideCtx, sideCanvas.width, sideCanvas.height, ["z", "y"]);
      drawTrailProjected(trailPoints3D, sideCtx, sideCanvas.width, sideCanvas.height, ["z", "y"]);
      sideCtx.restore();

      // 記録中なら記録
      if (isRecording) {
        const copy = landmarks.map(lm => ({ ...lm }));
        recordedFrames.push(copy);
        if (recordedFrames.length === 1) {
          playRecordBtn.disabled = false;
          clearRecordBtn.disabled = false;
        }
      }
    }

    // ==== Pose 初期化（Pose / Pose.Pose 両対応）====
    function initPose() {
      try {
        let PoseClass = null;

        if (typeof Pose === "undefined") {
          setStatus("カメラのみ動作中（Pose グローバルが存在しません）");
          return;
        }

        if (typeof Pose === "function") {
          PoseClass = Pose;
        } else if (typeof Pose === "object" && typeof Pose.Pose === "function") {
          PoseClass = Pose.Pose;
        } else {
          setStatus("カメラのみ動作中（Pose のクラス形状が想定と異なります）");
          return;
        }

        pose = new PoseClass({
          locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/pose@0.5/${file}`,
        });
        pose.setOptions({
          modelComplexity: 1,
          smoothLandmarks: true,
          enableSegmentation: false,
          selfieMode: true,
          minDetectionConfidence: 0.3,
          minTrackingConfidence: 0.3,
        });
        pose.onResults(onResults);
        poseReady = true;
        setStatus("カメラ起動成功。Pose 初期化完了。検出中...");
      } catch (e) {
        console.error(e);
        setStatus("Pose 初期化エラー: " + e.message);
      }
    }

    // ==== カメラデバイス管理 ====
    async function updateDeviceList() {
      try {
        const devices = await navigator.mediaDevices.enumerateDevices();
        videoDevices = devices.filter(d => d.kind === "videoinput");
        if (videoDevices.length === 0) {
          videoDevices = [];
          currentDeviceIndex = 0;
        } else if (!videoDevices[currentDeviceIndex]) {
          currentDeviceIndex = 0;
        }
        updateSwitchLabel();
      } catch (e) {
        console.error(e);
      }
    }

    function updateSwitchLabel() {
      if (videoDevices.length <= 1) {
        switchCameraBtn.textContent = "カメラ切替（1/1）";
      } else {
        switchCameraBtn.textContent =
          `カメラ切替（${currentDeviceIndex + 1}/${videoDevices.length})`;
      }
    }

    async function stopCamera() {
      if (videoStream) {
        videoStream.getTracks().forEach(t => t.stop());
        videoStream = null;
      }
    }

    async function startCameraStream() {
      if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
        setStatus("エラー: このブラウザは getUserMedia に対応していません。Chrome の最新版を使ってください。");
        return;
      }

      try {
        setStatus("カメラアクセス要求中...");

        let constraints;
        if (videoDevices.length > 0 && videoDevices[currentDeviceIndex]) {
          const devId = videoDevices[currentDeviceIndex].deviceId;
          constraints = {
            video: { deviceId: { exact: devId } },
            audio: false,
          };
        } else {
          constraints = {
            video: { facingMode: "user" },
            audio: false,
          };
        }

        const stream = await navigator.mediaDevices.getUserMedia(constraints);
        videoStream = stream;
        videoElement.srcObject = stream;
        await videoElement.play();
        setStatus("カメラ起動成功（Pose 初期化中...）");

        if (!devicesInitialized) {
          devicesInitialized = true;
          await updateDeviceList();
        }

        if (!poseReady) {
          initPose();
        }
      } catch (e) {
        console.error(e);
        setStatus("カメラ取得に失敗しました: " + e.name + " / " + e.message);
      }
    }

    // メインループ（1回だけ開始）
    async function frameLoop() {
      if (poseReady && pose && mode === "live" && videoElement.readyState >= 2) {
        try {
          await pose.send({ image: videoElement });
        } catch (e) {
          console.error(e);
          setStatus("Pose 処理中にエラー: " + e.message);
        }
      }
      if (loopStarted) {
        requestAnimationFrame(frameLoop);
      }
    }

    // ==== 録画・リプレイ ====
    startRecordBtn.addEventListener("click", () => {
      recordedFrames = [];
      isRecording = true;
      mode = "live";
      replayIndex = 0;
      trailPoints3D = [];
      startRecordBtn.disabled = true;
      stopRecordBtn.disabled = false;
      playRecordBtn.disabled = true;
      clearRecordBtn.disabled = true;
      setStatus("記録中... 動きを終えたら「記録停止」を押してください。");
    });

    stopRecordBtn.addEventListener("click", () => {
      isRecording = false;
      stopRecordBtn.disabled = true;
      startRecordBtn.disabled = false;
      playRecordBtn.disabled = recordedFrames.length === 0;
      clearRecordBtn.disabled = recordedFrames.length === 0;
      if (recordedFrames.length === 0) {
        setStatus("記録がありません。");
      } else {
        setStatus(`記録完了（フレーム数: ${recordedFrames.length}）。「リプレイ再生」で再生できます。`);
      }
    });

    clearRecordBtn.addEventListener("click", () => {
      recordedFrames = [];
      playRecordBtn.disabled = true;
      clearRecordBtn.disabled = true;
      setStatus("記録データを削除しました。");
    });

    playRecordBtn.addEventListener("click", () => {
      if (recordedFrames.length === 0) {
        setStatus("記録データがありません。");
        return;
      }
      mode = "replay";
      isRecording = false;
      replayIndex = 0;
      trailPoints3D = [];
      setStatus("リプレイ再生中...");

      // リプレイ中はカメラ映像を非表示
      videoElement.style.visibility = "hidden";

      startRecordBtn.disabled = true;
      stopRecordBtn.disabled = true;
      playRecordBtn.disabled = true;

      replayStep();
    });

    // ★ リプレイ：3ビュー同時に再生。速度は REPLAY_INTERVAL_MS で調整。
    function replayStep() {
      if (mode !== "replay") return;
      if (replayIndex >= recordedFrames.length) {
        mode = "live";
        setStatus("リプレイ終了。ライブモードに戻りました。");

        // カメラ映像を再表示
        videoElement.style.visibility = "visible";

        startRecordBtn.disabled = false;
        playRecordBtn.disabled = recordedFrames.length === 0;
        clearRecordBtn.disabled = recordedFrames.length === 0;
        return;
      }

      const landmarks = recordedFrames[replayIndex];
      resizeAllCanvases();

      // 軌跡用3Dポイント更新
      if (isTrailEnabled) {
        const targetKey = targetSelect.value;
        const p3d = getTargetPoint3D(targetKey, landmarks);
        if (p3d) {
          trailPoints3D.push(p3d);
          const MAX_POINTS = 200;
          if (trailPoints3D.length > MAX_POINTS) {
            trailPoints3D.splice(0, trailPoints3D.length - MAX_POINTS);
          }
        }
      }

      // 正面ビュー（x-y） ※リプレイ中は背景は黒（カメラは見えていない）
      frontCtx.save();
      frontCtx.clearRect(0, 0, frontCanvas.width, frontCanvas.height);
      drawSkeletonProjected(landmarks, frontCtx, frontCanvas.width, frontCanvas.height, ["x", "y"]);
      drawTrailProjected(trailPoints3D, frontCtx, frontCanvas.width, frontCanvas.height, ["x", "y"]);
      frontCtx.restore();

      // 上ビュー（x-z）
      topCtx.save();
      topCtx.clearRect(0, 0, topCanvas.width, topCanvas.height);
      drawSkeletonProjected(landmarks, topCtx, topCanvas.width, topCanvas.height, ["x", "z"]);
      drawTrailProjected(trailPoints3D, topCtx, topCanvas.width, topCanvas.height, ["x", "z"]);
      topCtx.restore();

      // 横ビュー（z-y）
      sideCtx.save();
      sideCtx.clearRect(0, 0, sideCanvas.width, sideCanvas.height);
      drawSkeletonProjected(landmarks, sideCtx, sideCanvas.width, sideCanvas.height, ["z", "y"]);
      drawTrailProjected(trailPoints3D, sideCtx, sideCanvas.width, sideCanvas.height, ["z", "y"]);
      sideCtx.restore();

      replayIndex++;
      if (mode === "replay") {
        setTimeout(replayStep, REPLAY_INTERVAL_MS);
      }
    }

    // ==== カメラ切替 ====
    switchCameraBtn.addEventListener("click", async () => {
      if (videoDevices.length <= 1) {
        setStatus("利用可能なカメラが1つだけのため、切り替えできません。");
        return;
      }
      currentDeviceIndex = (currentDeviceIndex + 1) % videoDevices.length;
      updateSwitchLabel();
      await stopCamera();
      await startCameraStream();
    });

    // ==== カメラ開始ボタン ====
    startButton.addEventListener("click", async () => {
      await startCameraStream();
      if (!loopStarted) {
        loopStarted = true;
        frameLoop();
      }
      setStatus("カメラ起動 & Pose 処理中...");
    });
  </script>
</body>
</html>
