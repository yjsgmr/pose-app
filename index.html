<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>Pose Tracking (MediaPipe公式スタイル版)</title>
  <!-- MediaPipe Pose / Drawing / Camera Utils -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #111827;
      color: #e5e7eb;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 16px;
      gap: 12px;
    }
    h1 { font-size: 1.2rem; margin-bottom: 4px; }
    .app-container {
      width: 100%;
      max-width: 480px;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    .controls {
      display: flex;
      gap: 8px;
      align-items: center;
      justify-content: space-between;
    }
    label { font-size: 0.85rem; }
    select {
      flex: 1;
      padding: 6px 8px;
      border-radius: 999px;
      border: 1px solid #374151;
      background: #020617;
      color: #e5e7eb;
      font-size: 0.9rem;
    }
    button {
      padding: 6px 10px;
      border-radius: 999px;
      border: none;
      font-size: 0.85rem;
      cursor: pointer;
      background: #f97316;
      color: white;
      font-weight: 600;
    }
    button:disabled { opacity: 0.4; cursor: not-allowed; }

    .video-wrapper {
      position: relative;
      width: 100%;
      border-radius: 24px;
      overflow: hidden;
      box-shadow: 0 18px 45px rgba(0, 0, 0, 0.6);
      background: black;
      aspect-ratio: 3 / 4;
    }
    video {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
      transform: scaleX(-1);
      display: block;
    }
    canvas {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      transform: scaleX(-1);
      pointer-events: none;
    }
    .hint {
      font-size: 0.75rem;
      color: #9ca3af;
      margin-top: 4px;
      line-height: 1.4;
    }
    .status {
      font-size: 0.75rem;
      color: #22c55e;
      margin-top: 4px;
      word-break: break-all;
    }
  </style>
</head>
<body>
  <div class="app-container">
    <h1>骨格検出 &amp; 軌跡表示（MediaPipe公式スタイル）</h1>

    <div class="controls">
      <label for="target">追跡パーツ：</label>
      <select id="target">
        <option value="center">体の中心</option>
        <option value="nose">頭（鼻）</option>
        <option value="left_wrist">左手首</option>
        <option value="right_wrist">右手首</option>
        <option value="left_ankle">左足首</option>
        <option value="right_ankle">右足首</option>
      </select>
      <button id="clear">軌跡クリア</button>
    </div>

    <div class="video-wrapper">
      <video class="input_video" id="video" playsinline></video>
      <canvas class="output_canvas" id="output"></canvas>
    </div>

    <p class="hint">
      ・明るい場所で、上半身〜全身がカメラに入るように少し離れてください。<br />
      ・骨格は水色、選択したパーツの軌跡はオレンジで表示されます。
    </p>
    <p class="status" id="status">初期化中...</p>
  </div>

  <script>
    const videoElement = document.getElementById("video");
    const canvasElement = document.getElementById("output");
    const canvasCtx = canvasElement.getContext("2d");
    const statusEl = document.getElementById("status");
    const targetSelect = document.getElementById("target");
    const clearButton = document.getElementById("clear");

    let trailPoints = [];

    function setStatus(msg) {
      statusEl.textContent = msg;
    }

    clearButton.addEventListener("click", () => {
      trailPoints = [];
    });

    function resizeCanvas() {
      const rect = canvasElement.getBoundingClientRect();
      canvasElement.width = rect.width;
      canvasElement.height = rect.height;
    }
    window.addEventListener("resize", resizeCanvas);

    // 追跡パーツのインデックス
    const LANDMARK_INDEX = {
      nose: 0,
      left_shoulder: 11,
      right_shoulder: 12,
      left_hip: 23,
      right_hip: 24,
      left_wrist: 15,
      right_wrist: 16,
      left_ankle: 27,
      right_ankle: 28,
    };

    function getTargetPoint(key, landmarks) {
      if (!landmarks) return null;

      if (key === "center") {
        const ls = landmarks[LANDMARK_INDEX.left_shoulder];
        const rs = landmarks[LANDMARK_INDEX.right_shoulder];
        const lh = landmarks[LANDMARK_INDEX.left_hip];
        const rh = landmarks[LANDMARK_INDEX.right_hip];
        if (!ls || !rs || !lh || !rh) return null;
        const cx = (ls.x + rs.x + lh.x + rh.x) / 4;
        const cy = (ls.y + rs.y + lh.y + rh.y) / 4;
        return { x: cx, y: cy };
      }

      const idx = LANDMARK_INDEX[key];
      return landmarks[idx] || null;
    }

    function drawTrail() {
      if (trailPoints.length < 2) return;
      canvasCtx.lineWidth = 4;
      canvasCtx.strokeStyle = "#ff9800"; // オレンジ
      canvasCtx.beginPath();
      for (let i = 0; i < trailPoints.length; i++) {
        const p = trailPoints[i];
        if (i === 0) canvasCtx.moveTo(p.x, p.y);
        else canvasCtx.lineTo(p.x, p.y);
      }
      canvasCtx.stroke();
    }

    function onResults(results) {
      resizeCanvas();
      canvasCtx.save();
      canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);

      // カメラ映像
      canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);

      const landmarks = results.poseLandmarks;
      if (!landmarks) {
        setStatus("Pose: ランドマーク未検出（体全体が映るように下がってみてください）");
        canvasCtx.restore();
        return;
      }

      setStatus("Pose: ランドマーク検出中！");

      // MediaPipe の公式ユーティリティで骨格描画（色だけ上書き）
      DrawingUtils.drawConnectors(
        canvasCtx,
        landmarks,
        Pose.POSE_CONNECTIONS,
        { color: "#00e5ff", lineWidth: 4 }  // 水色の骨格
      );
      DrawingUtils.drawLandmarks(
        canvasCtx,
        landmarks,
        { color: "#00e5ff", radius: 3 }    // 水色の点
      );

      // 追跡パーツの軌跡更新
      const targetKey = targetSelect.value;
      const targetPoint = getTargetPoint(targetKey, landmarks);
      if (targetPoint) {
        const px = targetPoint.x * canvasElement.width;
        const py = targetPoint.y * canvasElement.height;
        trailPoints.push({ x: px, y: py });

        const MAX_POINTS = 200;
        if (trailPoints.length > MAX_POINTS) {
          trailPoints.splice(0, trailPoints.length - MAX_POINTS);
        }
      }

      // 軌跡描画（オレンジ）
      drawTrail();

      canvasCtx.restore();
    }

    // Pose 初期化（公式サンプルに近い形）
    const pose = new Pose.Pose({
      locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`,
    });
    pose.setOptions({
      modelComplexity: 1,
      smoothLandmarks: true,
      enableSegmentation: false,
      selfieMode: true,               // 自撮り用
      minDetectionConfidence: 0.3,    // 検出しやすく
      minTrackingConfidence: 0.3,
    });
    pose.onResults(onResults);

    // Camera Utils の利用（公式スタイル）
    let camera = null;
    setStatus("カメラ起動準備中...");
    camera = new Camera.Camera(videoElement, {
      onFrame: async () => {
        await pose.send({ image: videoElement });
      },
      width: 480,
      height: 640,
    });
    camera.start();
    setStatus("カメラ起動 & Pose 処理中...");
  </script>
</body>
</html>
