<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>Pose Tracking Demo</title>
  <!-- MediaPipe Pose & Camera Utils CDN -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose@0.5/pose.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.3/camera_utils.js"></script>

  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #111827;
      color: #e5e7eb;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      padding: 16px;
      gap: 12px;
    }

    h1 {
      font-size: 1.2rem;
      margin-bottom: 4px;
    }

    .app-container {
      width: 100%;
      max-width: 480px;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .controls {
      display: flex;
      gap: 8px;
      align-items: center;
      justify-content: space-between;
    }

    label {
      font-size: 0.85rem;
    }

    select {
      flex: 1;
      padding: 6px 8px;
      border-radius: 999px;
      border: 1px solid #374151;
      background: #020617;
      color: #e5e7eb;
      font-size: 0.9rem;
    }

    button {
      padding: 6px 10px;
      border-radius: 999px;
      border: none;
      font-size: 0.85rem;
      cursor: pointer;
      background: #f97316;
      color: white;
      font-weight: 600;
    }

    button:disabled {
      opacity: 0.4;
      cursor: not-allowed;
    }

    .video-wrapper {
      position: relative;
      width: 100%;
      border-radius: 24px;
      overflow: hidden;
      box-shadow: 0 18px 45px rgba(0, 0, 0, 0.6);
      background: black;
      aspect-ratio: 3 / 4; /* スマホ縦向き想定 */
    }

    video {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
      transform: scaleX(-1); /* ミラー表示 */
      display: none; /* Canvas のみ表示するので隠す */
    }

    canvas {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      transform: scaleX(-1); /* video と同じくミラー */
    }

    .hint {
      font-size: 0.75rem;
      color: #9ca3af;
      margin-top: 4px;
      line-height: 1.4;
    }
  </style>
</head>
<body>
  <div class="app-container">
    <h1>骨格検出 &amp; 軌跡表示デモ</h1>

    <div class="controls">
      <label for="target">
        追跡パーツ：
      </label>
      <select id="target">
        <option value="center">体の中心</option>
        <option value="nose">頭（鼻）</option>
        <option value="left_wrist">左手首</option>
        <option value="right_wrist">右手首</option>
        <option value="left_ankle">左足首</option>
        <option value="right_ankle">右足首</option>
      </select>
      <button id="clear">軌跡クリア</button>
    </div>

    <div class="video-wrapper">
      <video id="video" playsinline></video>
      <canvas id="output"></canvas>
    </div>

    <p class="hint">
      ※Android 端末のブラウザでご利用ください。カメラ許可を求められたら「許可」を選択してください。<br />
      ※骨格は水色、選択したパーツの軌跡はオレンジで表示されます。
    </p>
  </div>

  <script>
    const videoElement = document.getElementById("video");
    const canvasElement = document.getElementById("output");
    const canvasCtx = canvasElement.getContext("2d");

    const targetSelect = document.getElementById("target");
    const clearButton = document.getElementById("clear");

    // 軌跡用バッファ
    let trailPoints = [];

    // Pose ランドマークのインデックス定義（MediaPipe Pose v0.5）
    const LANDMARK_INDEX = {
      nose: 0,
      left_shoulder: 11,
      right_shoulder: 12,
      left_elbow: 13,
      right_elbow: 14,
      left_wrist: 15,
      right_wrist: 16,
      left_hip: 23,
      right_hip: 24,
      left_knee: 25,
      right_knee: 26,
      left_ankle: 27,
      right_ankle: 28,
    };

    // 骨格の接続関係（簡易版）
    const SKELETON_CONNECTIONS = [
      // 胴体
      ["left_shoulder", "right_shoulder"],
      ["left_shoulder", "left_hip"],
      ["right_shoulder", "right_hip"],
      ["left_hip", "right_hip"],
      // 左腕
      ["left_shoulder", "left_elbow"],
      ["left_elbow", "left_wrist"],
      // 右腕
      ["right_shoulder", "right_elbow"],
      ["right_elbow", "right_wrist"],
      // 左脚
      ["left_hip", "left_knee"],
      ["left_knee", "left_ankle"],
      // 右脚
      ["right_hip", "right_knee"],
      ["right_knee", "right_ankle"],
      // 首〜頭
      ["nose", "left_shoulder"],
      ["nose", "right_shoulder"]
    ];

    // 軌跡クリア
    clearButton.addEventListener("click", () => {
      trailPoints = [];
    });

    // MediaPipe Pose 設定
    const pose = new Pose.Pose({
      locateFile: (file) =>
        `https://cdn.jsdelivr.net/npm/@mediapipe/pose@0.5/${file}`,
    });

    pose.setOptions({
      modelComplexity: 1,
      smoothLandmarks: true,
      enableSegmentation: false,
      minDetectionConfidence: 0.5,
      minTrackingConfidence: 0.5,
    });

    pose.onResults(onResults);

    // カメラセットアップ
    let camera;
    function startCamera() {
      camera = new Camera.Camera(videoElement, {
        onFrame: async () => {
          await pose.send({ image: videoElement });
        },
        width: 480,
        height: 640,
      });
      camera.start();
    }

    function resizeCanvas() {
      const rect = canvasElement.getBoundingClientRect();
      canvasElement.width = rect.width;
      canvasElement.height = rect.height;
    }

    window.addEventListener("resize", resizeCanvas);

    function onResults(results) {
      resizeCanvas();
      canvasCtx.save();
      canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);

      // 元画像（video）を描画
      if (results.image) {
        canvasCtx.drawImage(
          results.image,
          0,
          0,
          canvasElement.width,
          canvasElement.height
        );
      }

      const landmarks = results.poseLandmarks;
      if (!landmarks) {
        canvasCtx.restore();
        return;
      }

      // 骨格描画（水色）
      drawSkeleton(landmarks);

      // 選択パーツの座標を取得し、軌跡更新
      const targetKey = targetSelect.value;
      const targetPoint = getTargetPoint(targetKey, landmarks);
      if (targetPoint) {
        const px = targetPoint.x * canvasElement.width;
        const py = targetPoint.y * canvasElement.height;
        trailPoints.push({ x: px, y: py });

        // 軌跡は長くなりすぎないように制限
        const MAX_POINTS = 200;
        if (trailPoints.length > MAX_POINTS) {
          trailPoints.splice(0, trailPoints.length - MAX_POINTS);
        }
      }

      // 軌跡描画（オレンジ）
      drawTrail();

      canvasCtx.restore();
    }

    function drawSkeleton(landmarks) {
      canvasCtx.lineWidth = 3;
      canvasCtx.strokeStyle = "#00e5ff"; // 水色

      SKELETON_CONNECTIONS.forEach(([aKey, bKey]) => {
        const aIndex = LANDMARK_INDEX[aKey];
        const bIndex = LANDMARK_INDEX[bKey];
        const a = landmarks[aIndex];
        const b = landmarks[bIndex];
        if (!a || !b) return;

        const ax = a.x * canvasElement.width;
        const ay = a.y * canvasElement.height;
        const bx = b.x * canvasElement.width;
        const by = b.y * canvasElement.height;

        canvasCtx.beginPath();
        canvasCtx.moveTo(ax, ay);
        canvasCtx.lineTo(bx, by);
        canvasCtx.stroke();
      });

      // 各ランドマークに小さな点を打つ
      canvasCtx.fillStyle = "#00e5ff";
      landmarks.forEach((lm) => {
        const x = lm.x * canvasElement.width;
        const y = lm.y * canvasElement.height;
        canvasCtx.beginPath();
        canvasCtx.arc(x, y, 3, 0, Math.PI * 2);
        canvasCtx.fill();
      });
    }

    function drawTrail() {
      if (trailPoints.length < 2) return;
      canvasCtx.lineWidth = 4;
      canvasCtx.strokeStyle = "#ff9800"; // オレンジ
      canvasCtx.beginPath();
      for (let i = 0; i < trailPoints.length; i++) {
        const p = trailPoints[i];
        if (i === 0) {
          canvasCtx.moveTo(p.x, p.y);
        } else {
          canvasCtx.lineTo(p.x, p.y);
        }
      }
      canvasCtx.stroke();
    }

    // 追跡パーツの座標取得（体の中心も計算）
    function getTargetPoint(key, landmarks) {
      if (key === "center") {
        const ls = landmarks[LANDMARK_INDEX.left_shoulder];
        const rs = landmarks[LANDMARK_INDEX.right_shoulder];
        const lh = landmarks[LANDMARK_INDEX.left_hip];
        const rh = landmarks[LANDMARK_INDEX.right_hip];
        if (!ls || !rs || !lh || !rh) return null;

        const cx = (ls.x + rs.x + lh.x + rh.x) / 4;
        const cy = (ls.y + rs.y + lh.y + rh.y) / 4;
        return { x: cx, y: cy };
      }

      const index = LANDMARK_INDEX[key];
      return landmarks[index] || null;
    }

    // 起動
    startCamera();
  </script>
</body>
</html>
